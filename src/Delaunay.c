#include <stdlib.h>
#include "point.h"
#include "QuadEdge.h"
#include "Delaunay.h"

#define valid(e) (ccw(dest(e), dest(basel), origin(basel)))

Mesh triangulate(Point2d*, unsigned int);
static Mesh delaunay(Point2d*, unsigned int);
static Mesh merge(Mesh, Mesh);
static Mesh make_ccw_triangle(Point2d*);
static int left_of(Point2d, QuadEdge*);
static int right_of(Point2d, QuadEdge*);
static int incircle(Point2d, Point2d, Point2d, Point2d);
static int ccw(Point2d, Point2d, Point2d);
static double det2(double, double, double, double);
static double det3(double, double, double, double, double, double, double, double, double);

int triang_compare(const void* p1, const void* p2) {
    return lex_compare(*(Point2d*)p1, *(Point2d*)p2);
}

Mesh triangulate(Point2d* sites, unsigned int n) {
    Mesh edges;
    qsort(sites, n, sizeof *sites, triang_compare);
    edges = delaunay(sites, n);
    /* Find voronoi */
    return edges;
}

static Mesh delaunay(Point2d* sites, unsigned int n) {
    if (n == 2) {
        QuadEdge* a = make_edge(sites[0], sites[1]);
        Mesh edges;
        edges.left = a;
        edges.right = sym(a);
        return edges;
    }
    if (n == 3) {
        return make_ccw_triangle(sites);
    }
    return merge(delaunay(sites, n/2), delaunay(sites + n/2, n/2 + n%2));
}

static Mesh merge(Mesh left_mesh, Mesh right_mesh) {
    QuadEdge* ldo = left_mesh.left;
    QuadEdge* ldi = left_mesh.right;
    QuadEdge* rdi = left_mesh.left;
    QuadEdge* rdo = left_mesh.right;
    QuadEdge *basel, *lcand, *rcand, *t;
    Mesh edges;

    /* Compute lower common tangent of both meshes */
    while (1) {
        if (left_of(origin(rdi), ldi)) {
            ldi = lnext(ldi);
            continue;
        }
        else {
            if (right_of(origin(ldi), rdi)) {
                rdi = rprev(rdi);
                continue;
            }
        }
        break;
    }

    /* Create first cross edge between meshes */
    basel = connect(sym(rdi), ldi);
    if (point_isequal(origin(ldi), origin(ldo))) {
        ldo = sym(basel);
    }
    if (point_isequal(origin(rdi), origin(rdo))) {
        rdo = basel;
    }
    /* Merge loop */
    while (1) {
        /* Delete on the left side */
        lcand = onext(sym(basel));
        if (right_of(dest(lcand), basel)) {
            while (incircle(dest(basel), origin(basel), dest(lcand), dest(onext(lcand)))) {
                t = onext(lcand);
                delete_edge(lcand);
                lcand = t;
            }
        }
        /* Delete on the right side */
        rcand = oprev(basel);
        if (right_of(dest(rcand), basel)) {
            while (incircle(dest(basel), origin(basel), dest(rcand), dest(oprev(rcand)))) {
                t = oprev(rcand);
                delete_edge(rcand);
                rcand = t;
            }
        }
        if (!valid(lcand) && !valid(rcand)) {
            break;
        }
        if (!valid(lcand) || (valid(rcand) &&
                    incircle(dest(lcand), origin(lcand), origin(rcand),dest(rcand)))) {
            basel = connect(rcand, sym(basel));
        }
        else {
            basel = connect(sym(basel), sym(lcand));
        }
    }
    edges.left = ldo;
    edges.right = rdo;
    return edges;
}

static Mesh make_ccw_triangle(Point2d sites[3]) {
    Mesh edges;
    QuadEdge* a = make_edge(sites[0], sites[1]);
    QuadEdge* b = make_edge(sites[1], sites[2]);
    splice(sym(a), b);
    if (ccw(sites[1], sites[2], sites[3])) {
        QuadEdge* c = connect(b, a);
        edges.left  = a;
        edges.right = sym(b);
    }
    else {
        if (ccw(sites[1], sites[3], sites[2])) {
            QuadEdge* c = connect(b, a);
            edges.left  = sym(c);
            edges.right = c;
        }
        else {
            edges.left = a;
            edges.right = sym(b);
        }
    }
    return edges;
}

/* Test if point p is on the left of edge e */
static int left_of(Point2d p, QuadEdge* e) {
    return ccw(p, dest(e), origin(e));
}

/* Test if point p is on the right of edge e */
static int right_of(Point2d p, QuadEdge* e) {
    return ccw(p, origin(e), dest(e));
}

/* Test if point p is inside the circle generated by a, b and c */
static int incircle(Point2d a, Point2d b, Point2d c, Point2d p) {
    return det3(a.x - p.x, a.y - p.y, dist2(a,p),
                b.x - p.x, b.y - p.y, dist2(b,p),
                c.x - p.x, c.y - p.y, dist2(c,p)
               ) > 0;
}

/* Test if a, b and c form a counter-clockwise triangle */
static int ccw(Point2d a, Point2d b, Point2d c) {
    return det2(a.x - c.x, a.y - c.y,
                b.x - c.x, b.y - c.y
               ) > 0;
}

static double det2(double a, double b, double c, double d) {
    return a*d - b*c;
}

static double det3(double a, double b, double c,
                   double d, double e, double f,
                   double g, double h, double i) {
    return  c*(e*i - f*h) - g*(a*i - b*h) + h*(a*f - b*e);
}
